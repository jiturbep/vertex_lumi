// Local
#include "D3PDData/ATLASImport.h"
#include "D3PDData/AnaVtxTree.h"
#include "D3PDData/HistogramHelper.h"
#include "GlobalSettings/GlobalSettings.h"

// STL
#include <iostream>
#include <fstream>
#include <sstream>
#include <bitset>
#include <string>
#include <iomanip>

// ROOT
#include "TDataType.h"
#include "TMath.h"
#include "TVector2.h"
#include "TAxis.h"

////////////////////////////////////////////////////////////////////////////////////////
// Constructor
////////////////////////////////////////////////////////////////////////////////////////
AnaVtxTree::AnaVtxTree() : VtxTree()
  , m_GRLReader("../GoodRunsLists/data12_8TeV.periodAllYear_DetStatus-v54-pro13-04_DQDefects-00-00-33_PHYS_CombinedPerf_Tracking_Tracking.xml") // GRL reader tool
  , use_plbs(false) // Specify if pLBs are needed
  , split_maxdzsig(0.) // Split vertex re-merging
  , max_chi2ndf(-1.) // Apply cut on chi2/ndf of reconstructed vertices
  , current_pLB(-1) //store current pLB
  , current_pLB_run(-1) //store run for which we have loaded pLB info
  , pLBmin(100000) // Unreal value, must be set by LoadAndAddPseudoLBs at some point!
  , pLBmax(0)
  , dumpTxtFileName("") //by default no dumping on text file
  , physics_run(false)
  , qualityVertexVersion(3)
  , qualityVertexModifier(0)
  , qualityVertexParameter(5)
{};

////////////////////////////////////////////////////////////////////////////////////////
// TSelector begin
////////////////////////////////////////////////////////////////////////////////////////
void AnaVtxTree::SlaveBegin(TTree *tree) {
  //std::cout.precision(14);

  VtxTree::SlaveBegin(tree);
  flag_first = true;

  // --- Init output text file
  outputTxt.open((outputFileName + TString(".txt")).Data());

  // --- Create histograms? Can only do BCID-blind histos here...

  //Init counters
  m_TotEvents = 0;
  m_TotRawEvents = 0;
  m_triggerCounts["L1_BGRP7"] = 0;
  m_triggerCounts["L1_MBTS_2_BGRP7"] = 0;
  m_triggerCounts["L1_MBTS_2_BGRP7 && L1_BGRP7"] = 0;
  m_triggerCounts["L1_MBTS_2_BGRP7 && !L1_BGRP7"] = 0;
  m_triggerCounts["!L1_MBTS_2_BGRP7 && L1_BGRP7"] = 0;
  m_triggerCounts["!L1_MBTS_2_BGRP7 && !L1_BGRP7"] = 0;

  m_InitBcidHistograms = true;

  if (dumpTxtFileName != "") {
    std::cout << "[AnaVtxTree] INFO: Enabling dump on ASCII file: " << dumpTxtFileName << std::endl;
    //ok .. you want it.. dump on a text file
    dumpTxtFile.open(dumpTxtFileName.Data());
  }

  nTrkCuts.push_back(2);
  nTrkCuts.push_back(3); 
  nTrkCuts.push_back(4);
  nTrkCuts.push_back(5);
  nTrkCuts.push_back(7);
  nTrkCuts.push_back(10);

}

////////////////////////////////////////////////////////////////////////////////////////
// TSelector event loop
////////////////////////////////////////////////////////////////////////////////////////
Bool_t AnaVtxTree::Process(Long64_t entry) {

  // --- Setup trigger D3PD decoding tool
  if (trigMetaDataTree!=0 && triggerName != "" && !triggerTool) {
    triggerTool = new D3PD::TrigDecisionToolD3PD(fChain, trigMetaDataTree);
    std::cout << "[AnaVtxTree] INFO: Trigger tool initialized" << std::endl;
  }

  // --- Get event variables from TTree
  fChain->GetTree()->GetEntry(entry);

  // --- Print progress
  if (m_TotRawEvents % 1000 == 0) {
    std::cout << "[AnaVtxTree] INFO: Processing event " << m_TotRawEvents
              << "(Entry: " << entry << ", Tree #: " << fChain->GetTreeNumber() << ")" << std::endl;
  }
  ++m_TotRawEvents; // before GRL requirement

  // --- Don't check GRL for a VdM scan
  //if( !m_GRLReader.passedGRL( ei_RunNumber, ei_lbn ) ) {
  //  std::cout << "Failed GRL for runNumber("<<ei_RunNumber<<"), lbn("<<ei_lbn<<") " << std::endl;
  //}

  // --- Retrieve trigger tool if specified
  if (triggerTool) { triggerTool->GetEntry(entry); }

  // --- If this is the first event then set appropriate variables
  if( m_TotRawEvents == 1) { SetupLBInfo(ei_RunNumber); }

  // --- Quick rejection of events outside the scan based on LB, trigger and BCID
  if( (ei_RunNumber == 188949) && ( (ei_lbn <= 92) || (ei_lbn >= 160) ) ) { return false;}    
  if( (ei_RunNumber == 188951) && ( (ei_lbn <= 130) || (ei_lbn >= 185) ) ) {return false;}
  if (ei_RunNumber == 191373 || ei_RunNumber == 200805 || ei_RunNumber == 201351 ) {
    if (triggerTool and triggerName != "" && !(triggerTool->IsPassed(triggerName.Data())) ) { return false; } // Trigger
    if (find(bcidListCollisions.begin(), bcidListCollisions.end(), ei_bcid) == bcidListCollisions.end()) { return false; } // BCID
  }
    

  //Some pre-selection, based on timestamps.
  Double_t curTime = ei_timestamp + ei_timestamp_ns * TMath::Power(10.,-9);
  if ((ei_RunNumber == 188951) || (ei_RunNumber == 188949)) {
    if (timestampInScan(curTime) == 0) { return false; }
  }

  // 200805 hack trigger
  if ((ei_RunNumber == 200805) && (*trig_L1_TAV)[1] != 268435456) {
    return false;
  }

  // --- Initialise histograms
  if (m_InitBcidHistograms) {
    InitBCIDHists();
    m_InitBcidHistograms = false;
  } 
  //Find the pLB. Note that the variable current_pLB will specify the pLB if inside the scan, elsewise the normal lumiblock!

  //If input is data, decide whether to use pLBs or normal LBs.
  if (use_plbs) {

    bool goodPLB=false;
    for (unsigned int idx=0; idx < pseudoLB_Timestamps.size(); idx++) {
      if ((curTime >= pseudoLB_Timestamps[idx].second.first) && (curTime <= pseudoLB_Timestamps[idx].second.second)) {
        current_pLB = pseudoLB_Timestamps[idx].first;
        if (flag_first) {
          std::cout << "[AnaVtxTree] INFO: First event: " << m_TotRawEvents << std::endl;
          flag_first = false;
        }
        goodPLB = true;
        //if (m_TotRawEvents % 1000 == 0) std::cout << "current_pLB = " << current_pLB << std::endl;
        break;
      }
    }
    // discard event if pLB info is available and event is not inside that list
    if (!goodPLB) {
      return false;
    }

  } else {
    current_pLB = ei_lbn;
  }

  Int_t current_bcid;
  if (physics_run) {
    current_bcid = 0;
  } else {
    current_bcid = ei_bcid;
  }

  if (m_TotRawEvents % 1000 == 0) {
    std::cout << "[AnaVtxTree] INFO: current_pLB = " << current_pLB << std::endl;
  }

  ++m_TotEvents;

  //Get the index of the primary vertex
  Int_t TagVtxIndex=0;
  TagVtxIndex = isGoodVertex();
  
  //Set the event flags to false
  for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
    m_isTightBeforeSplitCorrection[*nTrkCut] = false;
    m_isTightAfterSplitCorrection[*nTrkCut] = false;
  }
  
  //Fill primary vertex histogram(s)
  if (TagVtxIndex >= 0) {
    h_privtx_z_pLB[current_bcid]->Fill((*vxnbc_z)[TagVtxIndex], current_pLB); 
  }

  h_events_pLB[current_bcid]->Fill(current_pLB); 
  
  //Increment the total number of "triggers" map
  NTrig[current_bcid][current_pLB]++;
  
  //Vertex counts before applying the split correction
  for (Int_t nv = 0; nv < vxnbc_n - 1; nv++) {
    if (max_chi2ndf > 0. && (*vxnbc_chi2)[nv] / (*vxnbc_ndof)[nv] > max_chi2ndf) {
      continue;
    }

    Int_t current_ntrk = (*vxnbc_nTracks)[nv];

    for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
      if (current_ntrk >= *nTrkCut) {
        NVtxBeforeSplitCorrection[*nTrkCut][current_bcid][current_pLB]++;
        m_isTightBeforeSplitCorrection[*nTrkCut] = true;
      }
    }
  }

#ifdef VERBOSE
  for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
    h_nvtx_pLB[*nTrkCut][current_bcid]->Fill(NVtxBeforeSplitCorrection[*nTrkCut][current_bcid][current_pLB], current_pLB);
  }
#endif

  //Evil hungry vertices cannibalize nearby smaller brethren.
  std::vector<Int_t> vtx_skip_list;
  for (Int_t nv = 0; nv < vxnbc_n - 1; nv++) {
    if (find(vtx_skip_list.begin(), vtx_skip_list.end(), nv) != vtx_skip_list.end()) {
      continue;
    }

    Int_t extra_tracks = 0;
    for (Int_t nv2 = nv; nv2 < vxnbc_n - 1; nv2++) {
      if (nv == nv2) {
        continue;
      }

      if (find(vtx_skip_list.begin(), vtx_skip_list.end(), nv2) != vtx_skip_list.end()) {
        continue;
      }

      float err1 = (*vxnbc_cov_z)[nv];
      float err2 = (*vxnbc_cov_z)[nv2];
      float err = TMath::Sqrt(err1 + err2);
      float dz = (*vxnbc_z)[nv] - (*vxnbc_z)[nv2];

      Int_t ntrk11 = (*vxnbc_nTracks)[nv];
      Int_t ntrk12 = (*vxnbc_nTracks)[nv2];
      for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
        if ((ntrk11 >= *nTrkCut) && (ntrk12 >= *nTrkCut)) {
          h_vtx_dz_dzsig[*nTrkCut]->Fill(dz, dz / err);
        }
      }

      if (TMath::Abs(dz) < split_maxdzsig * err) {
        vtx_skip_list.push_back(nv2);
        extra_tracks += (*vxnbc_nTracks)[nv2];

      } else {
#ifdef VERBOSE
        //Fill dz histograms.
        Int_t ntrk1 = (*vxnbc_nTracks)[nv];
        Int_t ntrk2 = (*vxnbc_nTracks)[nv2];
        for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
          if ((ntrk1 >= *nTrkCut) && (ntrk2 >= *nTrkCut)) {
            h_vtx_Dz_pLB[*nTrkCut][current_bcid]->Fill(dz, current_pLB);
          } else if ((ntrk1 >= *nTrkCut) && (ntrk2 < *nTrkCut)) {
            h_vtx_Dz_TightLoose_pLB[*nTrkCut][current_bcid]->Fill(dz, current_pLB);
          } else if ((ntrk1 < *nTrkCut) && (ntrk2 >= *nTrkCut)) {
            h_vtx_Dz_LooseTight_pLB[*nTrkCut][current_bcid]->Fill(dz, current_pLB);
          } else if ((ntrk1 < *nTrkCut) && (ntrk2 < *nTrkCut)) {
            h_vtx_Dz_LooseLoose_pLB[*nTrkCut][current_bcid]->Fill(dz, current_pLB);
          }
        }
#else
        //Still need the tight-tight for pileup masking purposes.
        Int_t ntrk1 = (*vxnbc_nTracks)[nv];
        Int_t ntrk2 = (*vxnbc_nTracks)[nv2];
        for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
          if ((ntrk1 >= *nTrkCut) && (ntrk2 >= *nTrkCut)) {
            h_vtx_Dz_pLB[*nTrkCut][current_bcid]->Fill(dz, current_pLB);
          }
        }
#endif
      }
    }
    (*vxnbc_nTracks)[nv] += extra_tracks;

    if (max_chi2ndf > 0. && (*vxnbc_chi2)[nv] / (*vxnbc_ndof)[nv] > max_chi2ndf) {
      continue;
    }

    h_vtx_nTracks_pLB[current_bcid]->Fill((*vxnbc_nTracks)[nv], current_pLB);

    for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
      if ((*vxnbc_nTracks)[nv] >= *nTrkCut) {
        NVtxAfterSplitCorrection[*nTrkCut][current_bcid][current_pLB]++;
        m_isTightAfterSplitCorrection[*nTrkCut] = true;
        h_vtx_z_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_z)[nv], current_pLB);

#ifdef VERBOSE
        //Less important histograms
        h_vtx_x_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_x)[nv],current_pLB);
        h_vtx_y_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_y)[nv],current_pLB);

        h_vtx_xx_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_cov_x)[nv],current_pLB);
        h_vtx_yy_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_cov_y)[nv],current_pLB);
        h_vtx_zz_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_cov_z)[nv],current_pLB);
        h_vtx_xy_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_cov_xy)[nv],current_pLB);
        h_vtx_xz_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_cov_xz)[nv],current_pLB);
        h_vtx_yz_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_cov_yz)[nv],current_pLB);

        h_vtx_chi2_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_chi2)[nv],current_pLB);
        h_vtx_ndof_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_ndof)[nv],current_pLB);
        h_vtx_chi2ndof_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_chi2)[nv]/(*vxnbc_ndof)[nv],current_pLB);
        h_vtx_px_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_px)[nv],current_pLB);
        h_vtx_py_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_py)[nv],current_pLB);
        h_vtx_pz_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_pz)[nv],current_pLB);
        h_vtx_E_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_E)[nv],current_pLB);
        h_vtx_sumPt_pLB[*nTrkCut][current_bcid]->Fill((*vxnbc_sumPt)[nv],current_pLB);

        if ((*trig_L1_TAV)[1] == 268435456) {
          h_L1_BGRP7_pLB[*nTrkCut][current_bcid]->Fill(current_pLB);
        }
        if ((*trig_L1_TAV)[3] == 2147483648) {
          h_L1_3J10_pLB[*nTrkCut][current_bcid]->Fill(current_pLB);
        }

        for (int itTrk=0; itTrk < (*vxnbc_nTracks)[nv]; itTrk++) {
          int idx = (*vxnbc_trk_index)[nv][itTrk];
          h_trk_pt_pLB[*nTrkCut][current_bcid]->Fill((*trk_pt)[idx], current_pLB);
          h_trk_eta_pLB[*nTrkCut][current_bcid]->Fill((*trk_eta)[idx], current_pLB);
          h_trk_chi2ndf_pLB[*nTrkCut][current_bcid]->Fill((*trk_chi2)[idx] / (*trk_ndof)[idx], current_pLB);
          h_trk_chi2_pLB[*nTrkCut][current_bcid]->Fill((*trk_chi2)[idx], current_pLB);
          h_trk_ndf_pLB[*nTrkCut][current_bcid]->Fill((*trk_ndof)[idx], current_pLB);
          h_trk_nBLHits_pLB[*nTrkCut][current_bcid]->Fill((*trk_nBLHits)[idx], current_pLB);
          h_trk_nPixHits_pLB[*nTrkCut][current_bcid]->Fill((*trk_nPixHits)[idx], current_pLB);
          h_trk_nSCTHits_pLB[*nTrkCut][current_bcid]->Fill((*trk_nSCTHits)[idx], current_pLB);
          h_trk_nTRTHits_pLB[*nTrkCut][current_bcid]->Fill((*trk_nTRTHits)[idx], current_pLB);
          h_trk_nTRTHighTHits_pLB[*nTrkCut][current_bcid]->Fill((*trk_nTRTHighTHits)[idx], current_pLB);
          h_trk_nPixHoles_pLB[*nTrkCut][current_bcid]->Fill((*trk_nPixHoles)[idx], current_pLB);
          h_trk_nSCTHoles_pLB[*nTrkCut][current_bcid]->Fill((*trk_nSCTHoles)[idx], current_pLB);
          h_trk_nTRTHoles_pLB[*nTrkCut][current_bcid]->Fill((*trk_nTRTHoles)[idx], current_pLB);
          h_trk_nHits_pLB[*nTrkCut][current_bcid]->Fill((*trk_nHits)[idx], current_pLB);
          //h_trk_nHoles_pLB[*nTrkCut][current_bcid]->Fill((*trk_nHoles)[idx], current_pLB);
        }
#endif
      }
    } // End NTrkCut loop
  } // End nv loop


  for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
    if (m_isTightBeforeSplitCorrection[*nTrkCut]) {
      NEvtBeforeSplitCorrection[*nTrkCut][current_bcid][current_pLB]++;
    }
    if (m_isTightAfterSplitCorrection[*nTrkCut]) {
      NEvtAfterSplitCorrection[*nTrkCut][current_bcid][current_pLB]++;
    }
  }

#ifdef VERBOSE
  h_evt_nvtx_before_remerge_pLB[current_bcid]->Fill(vxnbc_n, current_pLB);
  h_evt_nvtx_after_remerge_pLB[current_bcid]->Fill(vxnbc_n - vtx_skip_list.size(), current_pLB);
#endif
  return kTRUE;
}

void AnaVtxTree::SlaveTerminate() {

  if (dumpTxtFileName != "") {
    //close dumping file
    dumpTxtFile.close();
  }

  // Write and save VdM tree. Put it in a different file, just in case saving seg-faults.
  std::cout << "[AnaVtxTree] INFO: Saving VdM TTree to: " << (outputFileName + TString("_tree.root")) << std::endl;
  TFile *f_outputTree = TFile::Open((outputFileName + TString("_tree.root")), "RECREATE");


  Int_t entry_pLB;
  Int_t entry_BunchId;
  Float_t entry_NVtxBeforeSplitCorrection[nTrkCuts.size()];
  Float_t entry_NEvtBeforeSplitCorrection[nTrkCuts.size()];
  Float_t entry_NVtxAfterSplitCorrection[nTrkCuts.size()];
  Float_t entry_NEvtAfterSplitCorrection[nTrkCuts.size()];
  Float_t entry_NTrig;

  t_vdm = new TTree("t_vdm", "t_vdm");
  t_vdm->Branch( "pLB", &entry_pLB,"pLB/I");
  t_vdm->Branch( "BunchId",&entry_BunchId,"BunchId/I");
  t_vdm->Branch( "NTrig", &entry_NTrig,"NTrig/F");
  
  for (unsigned int i=0; i<nTrkCuts.size(); ++i) {
    const int trackCut( nTrkCuts.at(i) );
    t_vdm->Branch( TString::Format("NVtx%d_BSC",trackCut),
                   &(entry_NVtxBeforeSplitCorrection[i]),
                   TString::Format("NVtx%d_BSC/F",trackCut)
                 );
    t_vdm->Branch( TString::Format("NEvt%d_BSC",trackCut),
                   &(entry_NEvtBeforeSplitCorrection[i]),
                   TString::Format("NEvt%d_BSC/F",trackCut)
                 );
    t_vdm->Branch( TString::Format("NVtx%d_ASC",trackCut),
                   &(entry_NVtxAfterSplitCorrection[i]),
                   TString::Format("NVtx%d_ASC/F",trackCut)
                 );
    t_vdm->Branch( TString::Format("NEvt%d_ASC",trackCut),
                   &(entry_NEvtAfterSplitCorrection[i]),
                   TString::Format("NEvt%d_ASC/F",trackCut)
                 );
  }
  for (std::vector<Int_t>::iterator bcid = bcidListCollisions.begin(); bcid != bcidListCollisions.end(); ++bcid) {
    for (entry_pLB = pLBmin; entry_pLB <= pLBmax; entry_pLB++) {
      entry_BunchId = *bcid;
      for (unsigned int i=0; i<nTrkCuts.size(); i++) { 
        entry_NVtxBeforeSplitCorrection[i] = NVtxBeforeSplitCorrection[(nTrkCuts.at(i))][*bcid][entry_pLB];
        entry_NEvtBeforeSplitCorrection[i] = NEvtBeforeSplitCorrection[(nTrkCuts.at(i))][*bcid][entry_pLB];
        entry_NVtxAfterSplitCorrection[i] = NVtxAfterSplitCorrection[(nTrkCuts.at(i))][*bcid][entry_pLB];
        entry_NEvtAfterSplitCorrection[i] = NEvtAfterSplitCorrection[(nTrkCuts.at(i))][*bcid][entry_pLB];
      }
      entry_NTrig = NTrig[*bcid][entry_pLB];
      t_vdm->Fill();
    }
  }
  t_vdm->Write();
  f_outputTree->Close();

  // --- Print/save results
  std::cout << "[AnaVtxTree] INFO: Saving histograms to: " << (outputFileName + TString(".root")) << std::endl;
  TFile *outputNtp = TFile::Open((outputFileName + TString(".root")), "RECREATE");


  saveHistograms();

  // --- Close output files
  outputNtp->Close();
  outputTxt.close();

  std::cout<<"[AnaVtxTree] INFO: All Done." << std::endl;

}

void AnaVtxTree::saveHistograms() {
  //save all histograms in the hist/ subdirectory
  TDirectory *saveDir = gDirectory;
  gDirectory->mkdir("hist"); gDirectory->cd("hist");
  for( std::vector<TH1*>::iterator hist = HistogramHelper::histQueue.begin(); hist != HistogramHelper::histQueue.end(); ++hist ) {
    (*hist)->Write();
  }
  gDirectory = saveDir; gDirectory->cd();
}

void AnaVtxTree::LoadAndAddPseudoLB(TString fileName) {
  std::cout << "[AnaVtxTree] INFO: Opening fileName " << fileName.Data() << std::endl;
  ifstream tsFile(fileName.Data());
  if (not tsFile.is_open()) {
    std::cerr << "[AnaVtxTree] ERROR: Unable to open requested file with pseudo-LB info: " << fileName.Data() << std::endl;
    return;
  }

  Int_t pLB;
  Double_t ts_start, ts_end;

  std::vector<Int_t> pLB_list;
  std::vector<Double_t> ts_start_list;
  std::vector<Double_t> ts_end_list;

  while (tsFile.good()) {
    std::string line;
    getline(tsFile, line);
    if (line.empty()) {
      continue;
    }
    int prec=std::numeric_limits<long double>::digits10;
    std::stringstream istr;
    istr.precision(prec);
    istr << line;
    if (line.find_first_of("PseudoLB") != std::string::npos) {
      continue;  //header
    }
    istr >> pLB >> ts_start >> ts_end;
    std::pair<Double_t, Double_t> ts = std::make_pair<Double_t, Double_t>(ts_start, ts_end);
    pseudoLB_Timestamps.push_back(std::make_pair<Int_t, std::pair<Double_t, Double_t> >(pLB, ts) );
    //std::cout << "LB: " << pLB << ": " << ts_start << " - " << ts_end << std::endl;
    pLB_list.push_back(pLB);
    ts_start_list.push_back(ts_start);
    ts_end_list.push_back(ts_end);
  }

  sort(pLB_list.begin(), pLB_list.end());
  Int_t current_pLBmin = *(pLB_list.begin());
  Int_t current_pLBmax = *(pLB_list.end()-1);
  pLB_boundaries.push_back(std::make_pair<Int_t, Int_t>(current_pLBmin, current_pLBmax));
  if (current_pLBmin < pLBmin) {
    pLBmin = current_pLBmin;
  }
  if (current_pLBmax > pLBmax) {
    pLBmax = current_pLBmax;
  }
  tsFile.close();
  sort(ts_start_list.begin(), ts_start_list.end());
  sort(ts_end_list.begin(), ts_end_list.end());
  timestamp_boundaries.push_back(std::make_pair<Double_t, Double_t>(*(ts_start_list.begin()), *(ts_end_list.end()-1)));
}

int AnaVtxTree::timestampInScan(Double_t ts) {
  int scan = 0;
  for (std::vector<std::pair<Double_t, Double_t> >::iterator ts_boundary = timestamp_boundaries.begin(); ts_boundary != timestamp_boundaries.end(); ++ts_boundary) {
    if (ts >= (*ts_boundary).first && ts <= (*ts_boundary).second) {
      scan = distance(timestamp_boundaries.begin(), ts_boundary) + 1;
    }
  }
  return scan;
}

//Determine if vertexToCheck is a good vertex, if -1 check all verttices and find the first tagged good one
//qualityVertexVersion: x.y.z -- y and/or z can be omitted if 0
// x = general quality requirenents:
//    1 = standard
//    2 = DR requirement on 2-,3-track vertices
//    3 = Require at least N (default=5, otherwise=z) tracks pointing to the vertex
// y = additional vertex requirements
//    0 = none
//    1 = Accept only events where tagged vertex has N(=z) tracks
// z = Optional parameter for a given "y" mode
// examples:
// 1: standard
// 2.1.5: DR req. on 2-,3-trk vertices + tagged vertex required with at least 5 tracks
int AnaVtxTree::isGoodVertex(int vertexToCheck) {
  int taggedVertex = -1;

  if (qualityVertexVersion == 1) {
    //standard-definition
    Double_t minNTracks = qualityVertexParameter;
    if (minNTracks == 0) {
      minNTracks = 2;  //default value
    }
    if (vertexToCheck == -1) {
      //check only algorithm-tagged vertex
      if ((*vxnbc_nTracks)[0] >= minNTracks && (*vxnbc_cov_x)[0]!=0 && (*vxnbc_cov_y)[0]!=0 && vxnbc_n > 1) {
        taggedVertex=0;
      }
    } else {
      if ((*vxnbc_nTracks)[vertexToCheck] >= minNTracks && (*vxnbc_cov_x)[vertexToCheck]!=0 && (*vxnbc_cov_y)[vertexToCheck]!=0 && vxnbc_n > 1) {
        taggedVertex=vertexToCheck;
      }
    }
  } else if (qualityVertexVersion == 2) {
    //require vertex probability
    for (int ivx=0; ivx < vxnbc_n - 1; ++ivx) {
      if (vertexToCheck > -1 && ivx != vertexToCheck) {
        continue;  //next vertex
      }
      double probVertex = TMath::Prob((*vxnbc_chi2)[ivx], (*vxnbc_ndof)[ivx]);
      //      double dz=0.0;
      //for (std::vector<int>::iterator nvtrk = vxnbc_trk_index->at(ivx).begin(); nvtrk != vxnbc_trk_index->at(ivx).end(); ++nvtrk) {
      //  dr += TMath::Power()
      //}
      double Dr2=-999.;
      double Dr3=-999.;
      if (vxnbc_nTracks->at(ivx) == 2) {
        //Properties for events with 2 tracks at the Tagged vertex
        //evaluate delta d0 for vertices with 2 tracks
        if (vxnbc_trk_index->at(ivx).size() == 2) {
          // (Delta r)^2 = (d0)^2 + (d'0)^2 - 2(d0)(d'0)cos(Delta phi)
          double d01 = trk_d0_wrtPV->at(vxnbc_trk_index->at(ivx).at(0));
          double d02 = trk_d0_wrtPV->at(vxnbc_trk_index->at(ivx).at(1));
          double phi1 = trk_phi_wrtPV->at(vxnbc_trk_index->at(ivx).at(0));
          double phi2 = trk_phi_wrtPV->at(vxnbc_trk_index->at(ivx).at(1));
          double dphi = TMath::Abs(TVector2::Phi_mpi_pi(phi1 - phi2));
          Dr2 = TMath::Power(d01,2) + TMath::Power(d02,2) - 2*d01*d02*TMath::Cos(dphi);
          Dr2 = TMath::Sqrt(Dr2);
        }
      } else if (vxnbc_nTracks->at(ivx) == 3) {
        if (vxnbc_trk_index->at(ivx).size() == 3) {
          //evaluate average distance
          double d01 = trk_d0_wrtPV->at(vxnbc_trk_index->at(ivx).at(0));
          double d02 = trk_d0_wrtPV->at(vxnbc_trk_index->at(ivx).at(1));
          double d03 = trk_d0_wrtPV->at(vxnbc_trk_index->at(ivx).at(2));
          double phi1 = trk_phi_wrtPV->at(vxnbc_trk_index->at(ivx).at(0));
          double phi2 = trk_phi_wrtPV->at(vxnbc_trk_index->at(ivx).at(1));
          double phi3 = trk_phi_wrtPV->at(vxnbc_trk_index->at(ivx).at(2));
          double dphi12 = TMath::Abs(TVector2::Phi_mpi_pi(phi1 - phi2));
          double dphi13 = TMath::Abs(TVector2::Phi_mpi_pi(phi1 - phi3));
          double dphi23 = TMath::Abs(TVector2::Phi_mpi_pi(phi1 - phi2));
          Dr3 = TMath::Sqrt(TMath::Power(d01,2) + TMath::Power(d02,2) - 2*d01*d02*TMath::Cos(dphi12));
          Dr3 += TMath::Sqrt(TMath::Power(d01,2) + TMath::Power(d03,2) - 2*d01*d02*TMath::Cos(dphi13));
          Dr3 += TMath::Sqrt(TMath::Power(d02,2) + TMath::Power(d03,2) - 2*d01*d02*TMath::Cos(dphi23));
          Dr3 = Dr3 / 3;
        }
      }

      if ( ((*vxnbc_nTracks)[ivx] == 2 && probVertex > 0.01 && Dr2 < 2.5) ||
           ((*vxnbc_nTracks)[ivx] == 3 && probVertex > 1E-08 && Dr3 < 2.5) ||
           ((*vxnbc_nTracks)[ivx] > 3  && probVertex > 0)) {
        taggedVertex = ivx;
        break; // Vertex with highest sumPt2 with quality requirements
      }
    }
  } else if (qualityVertexVersion == 3) {
    Double_t minNTracks = qualityVertexParameter;
    if (minNTracks == 0) {
      minNTracks = 5;  //default value
    }
    for (int ivx=0; ivx < vxnbc_n - 1; ++ivx) {
      if (vertexToCheck > -1 && ivx != vertexToCheck) {
        continue;  //next vertex
      }
      if ((*vxnbc_nTracks)[ivx] >= minNTracks && (*vxnbc_cov_x)[ivx]!=0 && (*vxnbc_cov_y)[ivx]!=0) {
        taggedVertex = ivx;
        break;
      }
    }
  }

  if (qualityVertexModifier == 1) {
    //if tagged vertex has a number of tracks != qualityVertexParameter, un-tag the vertex
    if ((*vxnbc_nTracks)[taggedVertex] != qualityVertexParameter) {
      taggedVertex = -1;
    }
  }

  return taggedVertex;
}

void AnaVtxTree::SetDumpTxtFileName(TString name) {
  dumpTxtFileName = name;
}

void AnaVtxTree::SetTriggerFilter(TString p_triggerName, TChain *p_trigMetaDataTree) {
  triggerName = p_triggerName;
  if (p_trigMetaDataTree) {
    trigMetaDataTree = p_trigMetaDataTree;
  }
}

void AnaVtxTree::SetMaxChi2Ndf(Float_t p_max_chi2ndf) {

  std::cout << "[AnaVtxTree] INFO: Setting maximum chi2/ndf = " << p_max_chi2ndf << std::endl;
  max_chi2ndf = p_max_chi2ndf;

}

void AnaVtxTree::SetupLBInfo( const unsigned int &runNumber ) {
  // Run-by-run setup
  // - Specify BCIDs
  // - Load pLB timestamps

  // Load timestamp and pLB info
  std::cout << "[AnaVtxTree] INFO: Loading new list of pseudo LB info for run " << runNumber << std::endl;
  pseudoLB_Timestamps.clear();

  if (runNumber == 188949) { // 2011 mu-scan
    // Set pLB and BCID info
    use_plbs = true;
    bcidListCollisions.push_back(200);
    bcidListCollisions.push_back(999);
    // Load timestamps
    TString pathToPLBTimeStamps=GlobalSettings::path_timestamps+"188949/scan/";
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("timestamps1.dat")).Data()); //add list of pseudo-LB.
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("timestamps2.dat")).Data()); //add list of pseudo-LB.

  } else if (runNumber == 188951) { // 2011 mu-scan
    // Set pLB and BCID info
    use_plbs = true;
    bcidListCollisions.push_back(200);
    bcidListCollisions.push_back(999);
    // Load timestamps
    TString pathToPLBTimeStamps=GlobalSettings::path_timestamps+"188951/scan/";
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("timestamps3.dat")).Data()); //add list of pseudo-LB.

  } else if (runNumber == 182013) { // 2011 VdM-scan
    // Set pLB and BCID info
    use_plbs = true;
    bcidListCollisions.push_back(81);
    bcidListCollisions.push_back(867);
    bcidListCollisions.push_back(2752);
    // Load timestamps
    TString pathToPLBTimeStamps=GlobalSettings::path_timestamps+"182013/run/";
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("all_timestamps.dat")).Data()); //add list of pseudo-LB.

  } else if (runNumber == 191373) { // 2011/2012 something?
    // Set pLB and BCID info
    use_plbs = true;
    bcidListCollisions.push_back(1);
    // Load timestamps
    TString pathToPLBTimeStamps=GlobalSettings::path_timestamps+"191373/";
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("191373_timestamps.dat")).Data()); //add list of pseudo-LB.

  } else if (runNumber == 200805) { // 2012 VdM scan
    // Set pLB and BCID info
    use_plbs = false;
    bcidListCollisions.push_back(1);
    bcidListCollisions.push_back(149);
    bcidListCollisions.push_back(334);
    // Set lumiblocks by hand
    pLBmin = 1;
    pLBmax = 415;

  } else if (runNumber == 201351) { // 2012 VdM scan
    // Set pLB and BCID info
    use_plbs = true;
    bcidListCollisions.push_back(1);
    bcidListCollisions.push_back(241);
    bcidListCollisions.push_back(2881);
    bcidListCollisions.push_back(3121);
    // Load timestamps
    TString pathToPLBTimeStamps=GlobalSettings::path_timestamps+"201351/run/";
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("timestamps.dat")).Data()); //add list of pseudo-LB.
    
  } else if (runNumber == 215021) { // 2012 November VdM scan 15
    // Set pLB and BCID info
    use_plbs = true;
    bcidListCollisions.push_back(1);
    bcidListCollisions.push_back(2361);
    bcidListCollisions.push_back(2881);
    // Load timestamps
    TString pathToPLBTimeStamps=GlobalSettings::path_timestamps+"201351/run/";
    LoadAndAddPseudoLB((pathToPLBTimeStamps+TString("timestamps.dat")).Data()); //add list of pseudo-LB. 
  
 } else { // Otherwise, we're in a physics run, so run BCID-blind.
    // Set pLB and BCID info
    use_plbs = false;
    physics_run = true;
    bcidListCollisions.push_back(0);
    // Set lumiblocks by hand
    pLBmin = 1;
    pLBmax = 1500;
  }
  
  // Print pLB info
  nPLB = pLBmax - pLBmin + 1;
  std::cout << "/****************************************************/" << std::endl;
  std::cout << "/**            pLB Timestamp Summary               **/" << std::endl;
  std::cout << "/**     pLBmin = " << std::setw(5) << pLBmin << "                             **/" << std::endl;
  std::cout << "/**     pLBmax = " << std::setw(5) << pLBmax << "                             **/" << std::endl;
  std::cout << "/**     nPLB   = " << std::setw(5) << nPLB <<   "                             **/" << std::endl;
  std::cout << "/****************************************************/" << std::endl;
}

void AnaVtxTree::InitBCIDHists() {
  std::cout << "[AnaVtxTree] INFO: Initializing histograms" << std::endl;
  m_InitBcidHistograms = false;

TString h_bcid_name, h_bcid_title;

  // -- Maps <bcid, TH>
  for (std::vector<Int_t>::iterator ib = bcidListCollisions.begin(); ib != bcidListCollisions.end(); ++ib) {     
    
    h_privtx_z_pLB[*ib] = HistogramHelper::define2DHistogram( cstr("Primary vertex Z vs. pLB, BCID ",*ib),
                                             NBinsZAxis, LowZAxis, HighZAxis, nPLB, pLBmin, pLBmax+1,
                                             "Z (mm)", "pLB", true, cstr("PriVtxZpLB_BCID",*ib));
                                             
    h_events_pLB[*ib] = HistogramHelper::defineHistogram( cstr("NEvents per pLB, BCID ",*ib),
                                         nPLB, pLBmin, pLBmax+1,
                                         "pLB", "nEvents", true, cstr("NEvents_pLB_BCID",*ib) );

    h_vtx_nTracks_pLB[*ib] = HistogramHelper::define2DHistogram( cstr("Vertex NTrk, BCID ", *ib),
                             200., 0., 200., nPLB, pLBmin,pLBmax+1,
                             "nTracks", "pLB", true, cstr("VtxNTrk_BCID",*ib) );

#ifdef VERBOSE
    h_evt_nvtx_before_remerge_pLB[*ib] = HistogramHelper::define2DHistogram( cstr("NVtx distribution vs. pLB before remerging, BCID ",*ib),
                                         30, 0, 30, nPLB, pLBmin, pLBmax+1,
                                         "NVtx", "pLB", true, cstr("h_evt_nvtx_before_remerge_pLB_BCID",*ib) );

    h_evt_nvtx_after_remerge_pLB[*ib] = HistogramHelper::define2DHistogram(cstr("NVtx distribution vs. pLB after remerging, BCID ",*ib),
                                        30, 0, 30, nPLB, pLBmin, pLBmax+1,
                                        "NVtx", "pLB", true, cstr("h_evt_nvtx_after_remerge_pLB_BCID",*ib) );
#endif
  }

  // -- Single histograms
  for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
    h_vtx_dz_dzsig[*nTrkCut] = HistogramHelper::define2DHistogram(cstr("Vertex dz vs. dz signficance, NTrk >= ",*nTrkCut),
                               1000, -50, 50, 600, -30, 30,
                               "#Deltaz (mm)", "#Deltaz / #sigma_{#Deltaz}", true, cstr("h_vtx_dz_dzsig_NTrk",*nTrkCut) );
  }

  // -- Maps <NTrkCut, <bcid, TH > >
  for (std::vector<Int_t>::iterator nTrkCut = nTrkCuts.begin(); nTrkCut != nTrkCuts.end(); ++nTrkCut) {
    for (std::vector<Int_t>::iterator ib = bcidListCollisions.begin(); ib != bcidListCollisions.end(); ++ib) {
      h_vtx_z_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram( cstr( str("Vertex Z Position, BCID ",*ib), str("_NTrkCut",*nTrkCut) ),
                                   NBinsZAxis, LowZAxis, HighZAxis, nPLB, pLBmin,pLBmax+1,
                                   "Z (mm)", "pLB", true, cstr( str("VtxPosZpLB_BCID",*ib), str("_NTrkCut",*nTrkCut) ) );

      h_vtx_Dz_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr(str("Vertex Delta Z, Tight-Tight, BCID ",*ib),str(", NTrk >= ",*nTrkCut) ),
                                    NBinsDzAxis, LowDzAxis, HighDzAxis, nPLB, pLBmin,pLBmax+1,
                                    "#DeltaZ (mm)", "pLB", true, cstr( str("VtxDzTightTight_pLB_BCID",*ib), str("_NTrkCut",*nTrkCut) ));
      //Less important histograms
#ifdef VERBOSE

      h_vtx_Dz_LooseTight_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Delta Z, Loose-Tight, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
          NBinsDzAxis, LowDzAxis, HighDzAxis, nPLB, pLBmin,pLBmax+1,
          "#DeltaZ (mm)", "pLB", true, cstr( str("VtxDzLooseTight_pLB_BCID",*ib), str("_NTrkCut",*nTrkCut) ));

      h_vtx_Dz_TightLoose_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Delta Z, Tight-Loose, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
          NBinsDzAxis, LowDzAxis, HighDzAxis, nPLB, pLBmin,pLBmax+1,
          "#DeltaZ (mm)", "pLB", true, cstr( str("VtxDzTightLoose_pLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_Dz_LooseLoose_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Delta Z, Loose-Loose, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
          NBinsDzAxis, LowDzAxis, HighDzAxis, nPLB, pLBmin,pLBmax+1,
          "#DeltaZ (mm)", "pLB", true, cstr( str("VtxDzLooseLoose_pLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_x_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex PosX vs. pLB, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
          NBinsXAxis, LowXAxis, HighXAxis,nPLB, pLBmin,pLBmax+1,
          "X (mm)", "pLB", true, cstr( str("VtxPosXpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_y_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex PosY vs. pLB, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
          NBinsYAxis, LowYAxis, HighYAxis,nPLB, pLBmin,pLBmax+1,
          "Y (mm)", "pLB", true, cstr( str("VtxPosYpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_xx_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Cov XX, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsXAxis, 0., 0.1, nPLB, pLBmin,pLBmax+1,
                                    "cov XX (mm)", "pLB", true, cstr( str("VtxCovXXpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_yy_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Cov YY, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsXAxis, 0., 0.1, nPLB, pLBmin,pLBmax+1,
                                    "cov YY (mm)", "pLB", true, cstr( str("VtxCovYYpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_zz_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Cov ZZ, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsZAxis, 0., 0.1, nPLB, pLBmin,pLBmax+1,
                                    "cov ZZ (mm)", "pLB", true, cstr( str("VtxCovZZpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_xy_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Cov XY, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsXAxis, 0., 0.1, nPLB, pLBmin,pLBmax+1,
                                    "cov XY (mm)", "pLB", true, cstr( str("VtxCovXYpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_xz_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Cov XZ, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsXAxis, 0., 0.1, nPLB, pLBmin,pLBmax+1,
                                    "cov XZ (mm)", "pLB", true, cstr( str("VtxCovXZpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_yz_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Cov YZ, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsXAxis, 0., 0.1, nPLB, pLBmin,pLBmax+1,
                                    "cov YZ (mm)", "pLB", true, cstr( str("VtxCovYZpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      //Vertex quality info
      h_vtx_chi2_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Chi2, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                      200., 0., 200., nPLB, pLBmin,pLBmax+1,
                                      "#chi^{2}", "pLB", true, cstr( str("VtxChi2_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_ndof_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Ndf, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                      200., 0., 200., nPLB, pLBmin,pLBmax+1,
                                      "NDF", "pLB", true, cstr( str("VtxNdf_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_chi2ndof_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Chi2/Ndf, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                          200., 0., 5, nPLB, pLBmin,pLBmax+1,
                                          "#chi^{2}/NDF (mm)", "pLB", true, cstr( str("VtxChi2Ndf_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      //Energy and momentum
      h_vtx_px_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex X Momentum, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsXAxis, LowPXAxis, HighPXAxis, nPLB, pLBmin,pLBmax+1,
                                    "p_{x} (MeV)", "pLB", true, cstr( str("VtxPXpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_py_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Y Momentum, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsYAxis, LowPYAxis, HighPYAxis, nPLB, pLBmin,pLBmax+1,
                                    "p_{y} (MeV)", "pLB", true, cstr( str("VtxPYpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_pz_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Z Momentum, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    NBinsZAxis, LowPZAxis, HighPZAxis, nPLB, pLBmin,pLBmax+1,
                                    "p_{z} (MeV)", "pLB", true, cstr( str("VtxPZpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_E_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Energy, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                   1000, 0., 1000000, nPLB, pLBmin,pLBmax+1,
                                   "E (MeV)", "pLB", true, cstr( str("VtxEpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_vtx_sumPt_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Vertex Sum Pt, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                       1000, 0., 1000000, nPLB, pLBmin,pLBmax+1,
                                       "p_{T} (MeV)", "pLB", true, cstr( str("VtxSumPtpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_nvtx_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("NVtx vs. pLB, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                  30, -0.5, 29.5, nPLB, pLBmin, pLBmax+1,
                                  "NVtx", "pLB", true, cstr( str("NVtxpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ) );

      h_L1_BGRP7_pLB[*nTrkCut][*ib] = HistogramHelper::defineHistogram(cstr( str("Number of L1_BGRP7 triggers vs. pLB, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                      nPLB, pLBmin, pLBmax+1,
                                      "pLB", "NTrig_{L1_BGRP7}", true, cstr( str("L1_BGRP7_pLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_L1_3J10_pLB[*nTrkCut][*ib] = HistogramHelper::defineHistogram(cstr( str("Number of L1_3J10 triggers vs. pLB, BCID ",*ib), str(", NTrk >= ",*nTrkCut) ),
                                     nPLB, pLBmin, pLBmax+1,
                                     "pLB", "NTrig_{L1_3J10}", true, cstr( str("L1_3J10_pLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_pt_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track pT for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                    5000, 0., 100000, nPLB, pLBmin, pLBmax+1,
                                    "p_{T} (MeV)", "pLB", true, cstr( str("TrkPtpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_eta_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track eta for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                     100, -3., 3., nPLB, pLBmin, pLBmax+1,
                                     "#eta", "pLB", true, cstr( str("TrkEtapLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_chi2ndf_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track chi2/ndf for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                         100, -3., 3., nPLB, pLBmin, pLBmax+1,
                                         "#chi^{2}/NDF", "pLB", true, cstr( str("TrkChi2NdfpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_chi2_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track chi2 for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                      200, 0., 200., nPLB, pLBmin, pLBmax+1,
                                      "#chi^{2}", "pLB", true, cstr( str("TrkChi2pLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_ndf_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track ndf for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                     200, 0., 200., nPLB, pLBmin, pLBmax+1,
                                     "NDF", "pLB", true, cstr( str("TrkNdfpLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nBLHits_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nBLHits for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                         11, -0.5, 10.5, nPLB, pLBmin, pLBmax+1,
                                         "N_{hits-BL}", "pLB", true, cstr( str("TrkNBLHitspLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nPixHits_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nPixHits for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                          11, -0.5, 10.5, nPLB, pLBmin, pLBmax+1,
                                          "N_{hits-PIX}", "pLB", true, cstr( str("TrkNPIXHitspLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nSCTHits_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nSCTHits for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                          11, -0.5, 10.5,nPLB, pLBmin, pLBmax+1,
                                          "N_{hits-SCT}", "pLB", true, cstr( str("TrkNSCTHitspLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nTRTHits_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nTRTHits for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                          101, -0.5, 100.5, nPLB, pLBmin, pLBmax+1,
                                          "N_{hits-TRT}", "pLB", true,cstr( str("TrkNTRTHitspLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nTRTHighTHits_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nTRTHighTHits for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                          101, -0.5, 100.5, nPLB, pLBmin, pLBmax+1,
                                          "N_{hits-TRT-highT}", "pLB", true, cstr( str("TrkNTRTHighTHitspLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nPixHoles_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nPixHoles for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                           11, -0.5, 10.5, nPLB, pLBmin, pLBmax+1,
                                           "N_{holes-PIX}", "pLB", true, cstr( str("TrkNPixHolespLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nSCTHoles_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nSCTHoles for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                           11, -0.5, 10.5, nPLB, pLBmin, pLBmax+1,
                                           "N_{holes-SCT}", "pLB", true, cstr( str("TrkNSCTHolespLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nTRTHoles_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nTRTHoles for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                           101, -0.5, 100.5, nPLB, pLBmin, pLBmax+1,
                                           "N_{holes-TRT}", "pLB", true, cstr( str("TrkNTRTHolespLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nHits_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nHits for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                       31, -0.5, 30.5, nPLB, pLBmin, pLBmax+1,
                                       "N_{hits}", "pLB", true, cstr( str("TrkNHitspLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

      h_trk_nHoles_pLB[*nTrkCut][*ib] = HistogramHelper::define2DHistogram(cstr( str("Track nHoles for tracks associated with vertices vs. pLB, BCID",*ib), str(", NTrk >= ",*nTrkCut) ),
                                        31, -0.5, 30.5, nPLB, pLBmin, pLBmax+1,
                                        "N_{holes}", "pLB", true, cstr( str("TrkNHolespLB_BCID",*ib), str(", NTrk >= ",*nTrkCut) ));

#endif


      // -- Maps <NTrkCut, <bcid, <pLB, count > > >
      for (Int_t current_pLB = pLBmin; current_pLB <= pLBmax; current_pLB++) {
        NVtxBeforeSplitCorrection[*nTrkCut][*ib][current_pLB] = 0;
        NEvtBeforeSplitCorrection[*nTrkCut][*ib][current_pLB] = 0;
        NVtxAfterSplitCorrection[*nTrkCut][*ib][current_pLB] = 0;
        NEvtAfterSplitCorrection[*nTrkCut][*ib][current_pLB] = 0;

        if (*nTrkCut == 2) {
          //Only once, we need to initialize the number of triggers per pLB to zero.
          NTrig[*ib][current_pLB] = 0;
        }
      } // end pLB loop
    } // end bcid loop
  } // end ntrk loop
}

